---
title: 다이나믹 프로그래밍
date: 2021-06-24 16:12:04
category: coding-test
thumbnail: './image/'
draft: false
---

- 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상키는 방법이다.
- 이미 계산된 결과는(작은 문제) 별도위 메모리 영역에 저장하여 다시 계산하지 않는다.
- 동적 계획법이라고 명명하기도 한다.

### 다이나믹 프로그래밍의 조건

1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제 해결 가능
2. 중복되는 부분 문제 : 동일한 작은 문제 반복적 해결

<hr/>

ex : 피보나치 수열

`fibo.py`

- 단순 재귀함수로 구현

```python
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fibo(4))
# 3
```

### Memoization

- 메모제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나
- 한 번 계산한 결과를 메모리 공간에 메모 (Caching)

<hr/>

`fibo_DP.py`

- 보텀업 다이나믹 프로그래밍 소스코드

```python
#DP 테이블 초기화
d = [0] * 100

d[1] = 1
d[2] = 1

#현재 fibo(99)출력
n = 99

for i in range(3, n+1):
    d[i] = d[i-1]+d[i-2]
return (d[n])

```

- 메모제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도 O(N)입니다.

### 다이나믹 프로그래밍 vs 분할 정복

- 공통점 : 다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용할 수 있습니다. (즉, 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황)
- 차이점 : 다이나믹 프로그래밍 문제는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다. 그러나 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.

##### 분할정복

ex: 퀵정렬

- 분할 이후 피벗을 다시 처리하는 부분 문제 호출하지 않음

### 다이나믹 프로그래밍 문제에 접근하는 방법

- 가장 먼저 그리디, 완전 탐색 등의 아이디어로 문제 해결이 가능한 지 검토
- 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍 고려

- 일단 재귀함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면 코드 개선 방법 사용하기
- 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많다.

### 실전 문제 : 개미 전사

- i 번째 식량창고까지의 얻을 수 있는 식량의 최댓값으로 DP 테이블 값을 채운다.
- i-1 vs i-2 + (현재 식량 창고 = k(i)) 를 비교하여 구할 수 있다.

`ant.py`

```python
#입력값 받기
n = int(input())

array = list(map(int, input().split()))

d = [0] * 100

# 0, 1의 DP 테이블 체우기
d[0] = array[0]
d[1] = max(array[0], array[1])

# 전체 DP 테이블 채우기
for i in range(2,n):
   d[i] = max(d[i-1], d[i-2]+array[i])

print(d[n-1])
```

### 실전문제 : 1로 만들기

- 최적 부분 구조와 중보기되는 부분 문제를 만족
- '그리디 문제'가 아닌 이유는 꼭 큰수로 나눈다고 해서 최적의 값이 나오는 상황이 아니기 때문이다.
  ex : 1을 빼고 5로 나눈 경우

`making_one.py`

```python
x = int(input())

d = [0]*30001

#3가지 연산 중 가장 작은 값을 dp 테이블에 넣어준다. 
for i in range(2, x+1):
    d[i] = d[i-1] + 1

    if i % 2 ==0:
        d[i] = min(d[i], d[i//2]+1)

    if i % 3 ==0:
        d[i] = min(d[i], d[i//3]+1)

    if i % 5 ==0:
        d[i] = min(d[i], d[i//5]+1)

print(d[x])
```
