---
title: 그리디 알고리즘
date: 2021-03-02 16:12:04
category: algorithm
thumbnail: './image/'
draft: false
---

**그리디 알고리즘**

- 그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법입니다.
- 일반적인 그리디 알고리즘은 문제 해결의 아이디어를 떠올릴 수 있어야 합니다.
- 즉, 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는 검토해야 합니다.

1. 예시
   - 문제상황 : 루트 노드부터 시작하여 거쳐 가는 노드 값의 합을 최대로 만들기
   - 해법(1) : 매 상황에서 가장 큰 값 고르기->해결불
2. 문제점

   - 일반적 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다.
   - 하지만 코딩테스트에서, 그리디 알고리즘 이용을 추론할 수 있다면 탐욕법으로 얻은 해가 최적의 해가 되는 상황으로 출제되는 경우가 있습니다.

3. 대표적 문제 (거스름 돈)
   - 문제 상황 : 거스름돈이 N원일 때 거슬러 주어야 할 동전의 최소 개 구하기
   - 해법(1) : 가장 큰 화폐 단위부터 거술러 주기 ->그리디 알고리즘
   - 정답 이유 : 동전의 경우 큰 단위가 항상 작은 단위의 배수이기 떄문입니다. 큰 단위가 작은 단위의 배수가 아니라면 정답을 보장할 수 없습니다.

`시행착오.py`

```python
charge = 800;

num_500 = 0
num_100 = 0
num_50 = 0
num_10 = 0


if charge > 500:
    charge -= 500
    num_500 = num_500 + 1
elif charge > 100:
    charge -= 100
    num_100 = num_100 + 1
...

# 위의 코드는 반복을 위해 for 문 안에 또 반복문을 써서 복잡한 프로그램이 된다.
#파이썬에서는 array를 잘 사용하는 것이 중요하다.
```

`정답.py`

```python
# 1_Greedy_거스름돈
charge = 1700

coin_array = [500, 100, 50, 10]
count = 0

for coin in coin_array:
    if(charge >= coin):
        count += charge//coin
        charge %= coin

print(count)
#출력 : 5
```

- 정답의 시간복잡도
  - 화폐의 종류가 K 이면 소스코드의 시간복잡도는 O(K)입니다.
  - 이 알고리즘의 시간복잡도는 거슬러줘야 하는 금액과 무관하고, 동전의 총 종류에만 영향을 받습니다.

`정답.cpp`

```c++
#include <bits/stdc++.h>

using namespace std;

int n = 1260;
int cnt;

int coinTypes[4] = {500, 100, 50, 10};

int main(void){
    for(int i = 0; i<4;i++){
        cnt += n / coinTypes[i];
        n %= coinTypes[i];
    }
    count << cnt << '\n';
}
```
